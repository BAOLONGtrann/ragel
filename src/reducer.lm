reduction TopLevel
	#
	# def statement
	#

	# def join
	#	[join `, expression] :Rec
	# |	[expression] :Base
	ragel::join 
	{
		Join *join;
	}

	ragel::join :Rec
	{
		Join *join = $_join->join;
		join->exprList.append( $expression->expr );
		$$->join = join;
	}

	ragel::join :Base
	{
		$$->join = new Join( $expression->expr );
	}
	
	# def expression
	#	[expr_left expression_op_list] :Expression
	ragel::expression
	{
		Expression *expr;
	}

	ragel::expression :Expression
	{
		// 1. reverse the list
		// 2. put the new term at the end.
		Expression *prev = new Expression( $expr_left->term );
		Expression *cur = $expression_op_list->expr;
		while ( cur != 0 ) {
			Expression *next = cur->expression;

			/* Reverse. */
			cur->expression = prev;

			prev = cur;
			cur = next;
		}

		$$->expr = prev;
	}

	ragel::expr_left
	{
		Term *term;
	}

	ragel::expr_left :Term
	{
		$$->term = $term->term;
	}

	# def expression_op_list
	#	[expression_op expression_op_list] :Op
	# |	[] :Empty
	ragel::expression_op_list
	{
		Expression *expr;
	}

	ragel::expression_op_list :Op
	{
		$$->expr = new Expression( $_expression_op_list->expr,
				$expression_op->term, $expression_op->type );
	}

	ragel::expression_op_list :Empty
	{
		$$->expr = 0;
	}


	# def expression_op
	# 	[`| term] :Or
	# |	[`& term] :And
	# |	[`- term] :Sub
	# |	[`-- term] :Ssub
	ragel::expression_op
	{
		Expression::Type type;
		Term *term;
	}

	ragel::expression_op :Or
	{
		$$->type = Expression::OrType;
		$$->term = $term->term;
	}

	ragel::expression_op :And
	{
		$$->type = Expression::IntersectType;
		$$->term = $term->term;
	}

	ragel::expression_op :Sub
	{
		$$->type = Expression::SubtractType;
		$$->term = $term->term;
	}

	ragel::expression_op :Ssub
	{
		$$->type = Expression::StrongSubtractType;
		$$->term = $term->term;
	}


	# def term
	#	[term_left term_op_list_short] :Term
	ragel::term
	{
		Term *term;
	}

	ragel::term :Term
	{
		// 1. reverse the list
		// 2. put the new term at the end.
		Term *prev = new Term( $term_left->fwa );
		Term *cur = $term_op_list_short->term;
		while ( cur != 0 ) {
			Term *next = cur->term;

			/* Reverse. */
			cur->term = prev;

			prev = cur;
			cur = next;
		}

		$$->term = prev;
	}

	# def term_left
	#	[factor_label] :FactorLabel
	ragel::term_left
	{
		FactorWithAug *fwa;
	}

	ragel::term_left :FactorLabel
	{
		$$->fwa = $factor_label->fwa;
	}

	# # This list is done manually to get shortest match.
	# def term_op_list_short
	# 	[] :Empty
	# |	[term_op term_op_list_short] :Terms
	ragel::term_op_list_short
	{
		Term *term;
	}

	ragel::term_op_list_short :Empty
	{
		$$->term = 0;
	}

	ragel::term_op_list_short :Terms
	{
		$$->term = new Term( $_term_op_list_short->term,
				$term_op->fwa, $term_op->type );
	}


	# def term_op
	#	[factor_label] :None
	# |	[`. factor_label] :Dot
	# |	[`:> factor_label] :ColonLt
	# |	[`:>> factor_label] :ColonLtLt
	# |	[`<: factor_label] :GtColon
	ragel::term_op
	{
		Term::Type type;
		FactorWithAug *fwa;
	}

	ragel::term_op :None
	{
		$$->type = Term::ConcatType;
		$$->fwa = $factor_label->fwa;
	}

	ragel::term_op :Dot
	{
		$$->type = Term::ConcatType;
		$$->fwa = $factor_label->fwa;
	}

	ragel::term_op :ColonLt
	{
		$$->type = Term::RightStartType;
		$$->fwa = $factor_label->fwa;
	}

	ragel::term_op :ColonLtLt
	{
		$$->type = Term::RightFinishType;
		$$->fwa = $factor_label->fwa;
	}

	ragel::term_op :GtColon
	{
		$$->type = Term::LeftType;
		$$->fwa = $factor_label->fwa;
	}

	# def factor_label
	#	[word `: factor_label] :Label
	# |	[factor_ep] :Ep
	ragel::factor_label
	{
		FactorWithAug *fwa;
	}

	ragel::factor_label :Label
	{
		InputLoc loc = @word;
		string label( $word->data, $word->length );
		$_factor_label->fwa->labels.prepend( Label(loc, label) );

		$$->fwa = $_factor_label->fwa;
	}

	ragel::factor_label :Ep
	{
		$$->fwa = $factor_ep->fwa;
	}

	# def factor_ep
	#	[factor_aug `-> epsilon_target] :Epsilon
	# |	[factor_aug] :Base
	ragel::factor_ep
	{
		FactorWithAug *fwa;
	}

	ragel::factor_ep :Epsilon
	{
//		InputLoc loc = FactorEp.loc();
//		factorWithAug = loadFactorAug( FactorEp.factor_aug() );
//		NameRef *nameRef = loadEpsilonTarget( FactorEp.epsilon_target() );
//
//		/* Add the target to the list and return the factor object. */
//		factorWithAug->epsilonLinks.append( EpsilonLink( loc, nameRef ) );

		$$->fwa = $factor_aug->fwa;
	}

	ragel::factor_ep :Base
	{
		$$->fwa = $factor_aug->fwa;
	}

	# def epsilon_target
	# 	[epsilon_target `:: word] :Rec
	# |	[word] :Base

	# def named_action_ref
	#	[word]

	# def action_ref 
	#	[named_action_ref] :NamedRef
	# |	[`( named_action_ref `)] :ParenNamed
	# |	[action_block] :Block
	ragel::action_ref
	{
		Action *action;
	}

	ragel::action_ref :NamedRef
	{
		/* Set the name in the actionDict. */
		string data( $word->data, $word->length );
		Action *action = pd->actionDict.find( data );
		if ( action != 0 ) {
			/* Pass up the action element */
			$$->action = action;
//			if ( action->paramList != 0 )
//				reject();
		}
		else {
			/* Will recover by returning null as the action. */
			error(@word) << "action lookup of \"" << data << "\" failed" << endl;
			$$->action = 0;
		}
	}

	ragel::action_ref :ParenNamed
	{

	}

	ragel::action_ref :Block
	{
		/* Create the action, add it to the list and pass up. */
		Action *newAction = new Action( &$action_block->loc, std::string(),
				$action_block->inlineList, pd->nextCondId++ );
		pd->actionList.append( newAction );
		$$->action = newAction;
	}

	# def action_spec
	#	[`action word opt_action_params action_block] :ActionSpec commit
	ragel::action_spec
	{
		Action *action;
	}

	ragel::action_spec :ActionSpec
	{
		string data( $word->data, $word->length );
		if ( pd->actionDict.find( data ) ) {
			/* Recover by just ignoring the duplicate. */
			error(@word) << "action \"" << data << "\" already defined" << endl;
		}
		else {
			//std::cerr << "NEW ACTION " << $2->data << " " << $4->inlineList << std::endl;
			/* Add the action to the list of actions. */
			Action *newAction = new Action( @1, data, 
					$action_block->inlineList, pd->nextCondId++ );

			/* Insert to list and dict. */
			pd->actionList.append( newAction );
			pd->actionDict.insert( newAction );

//			newAction->paramList = $3->paramList;
//			if ( $3->paramList != 0 )
//				newAction->argListMap = new ActionArgListMap;
		}
	//	parseSubstitutions = false;
	}


	# def action_block
	#	[`{ c_select     CInlineBlock: c_inline::inline_block `}] :C
	# |	[`{ ruby_select  RubyInlineBlock: ruby_inline::inline_block ruby_inline::`}]
	# |	[`{ ocaml_select OCamlInlineBlock: ocaml_inline::inline_block ocaml_inline::`}]
	# |	[`{ crack_select OCamlInlineBlock: crack_inline::inline_block crack_inline::`}]
	ragel::action_block
	{
		colm_location loc;
		InlineList *inlineList;
	}

	ragel::action_block :C
	{
		$$->loc = *@1;
		$$->inlineList = $CInlineBlock->inlineList;
	}

	# def inline_block
	#	[block_item_list] :List
	c_inline::inline_block
	{
		InlineList *inlineList;
	}

	c_inline::inline_block :List
	{
		$$->inlineList = $block_item_list->inlineList;
	}

	# def block_item_list
	# 	[block_item block_item_list] :Rec
	# |	[] :Base
	c_inline::block_item_list
	{
		InlineList *inlineList;
	}

	c_inline::block_item_list :Rec
	{
		$$->inlineList = $_block_item_list->inlineList;

		if ( $block_item->inlineItem != 0 )
			$$->inlineList->prepend( $block_item->inlineItem );
		else if ( $block_item->inlineList != 0 ) {
			$$->inlineList->prepend( *$block_item->inlineList );
			delete $block_item->inlineList;
		}
	}

	c_inline::block_item_list :Base
	{
		$$->inlineList = new InlineList;
	}
	
	# def block_item
	#	[expr_any] :ExprAny
	# |	[block_symbol] :BlockSymbol
	# |	[block_interpret] :BlockInterpret
	# |	[`{ inline_block `}] :RecBlock
	c_inline::block_item
	{
		InlineItem *inlineItem;
		InlineList *inlineList;
	}

	c_inline::block_item :ExprAny
	{
		$$->inlineItem = $expr_any->inlineItem;
	}

	c_inline::block_item :BlockSymbol
	{
		$$->inlineItem = $block_symbol->inlineItem;
	}

	c_inline::block_item :BlockInterpret
	{
		$$->inlineItem = $block_interpret->inlineItem;
	}

	c_inline::block_item :RecBlock
	{
		$$->inlineList = $inline_block->inlineList;
		$$->inlineList->prepend( new InlineItem( @1, "{", InlineItem::Text ) );
		$$->inlineList->append( new InlineItem( @1, "}", InlineItem::Text ) );
		$$->inlineItem = 0;
	}

	# def expr_any
	#	[whitespace] :WS
	#|	[comment] :Comment
	#|	[string] :String
	#|	[number] :Number
	#|	[hex_number] :Hex
	#|	[ident] :Ident
	#|	[c_any] :Any
	c_inline::expr_any
	{
		InlineItem *inlineItem;
	}

	c_inline::expr_any :WS
	{
		string data( $whitespace->data, $whitespace->length );
		$$->inlineItem = new InlineItem( @whitespace, data, InlineItem::Text );
	}
		
	c_inline::expr_any :Comment
	{
		string data( $comment->data, $comment->length );
		$$->inlineItem = new InlineItem( @comment, data, InlineItem::Text );
	}

	c_inline::expr_any :String
	{
		string data( $string->data, $string->length );
		$$->inlineItem = new InlineItem( @string, data, InlineItem::Text );
	}

	c_inline::expr_any :Number
	{
		string data( $number->data, $number->length );
		$$->inlineItem = new InlineItem( @number, data, InlineItem::Text );
	}

	c_inline::expr_any :Hex
	{
		string data( $hex_number->data, $hex_number->length );
		$$->inlineItem = new InlineItem( @hex_number, data, InlineItem::Text );
	}

	c_inline::expr_any :Ident
	{
		string data( $ident->data, $ident->length );
		$$->inlineItem = new InlineItem( @ident, data, InlineItem::Text );
	}

	c_inline::expr_any :Any
	{
		string data( $c_any->data, $c_any->length );
		$$->inlineItem = new InlineItem( @c_any, data, InlineItem::Text );
	}

	# def block_symbol
	#	[`,] :B1 | [`;] :B2 | [`(] :B3 | [`)] :B4 | [`*] :B5 | [`::] :B6
	c_inline::block_symbol
	{
		InlineItem *inlineItem;
	}

	c_inline::block_symbol :B1
	{
		string data( $1->data, $1->length );
		$$->inlineItem = new InlineItem( @1, data, InlineItem::Text );
	}

	c_inline::block_symbol :B2
	{
		string data( $1->data, $1->length );
		$$->inlineItem = new InlineItem( @1, data, InlineItem::Text );
	}

	c_inline::block_symbol :B3
	{
		string data( $1->data, $1->length );
		$$->inlineItem = new InlineItem( @1, data, InlineItem::Text );
	}

	c_inline::block_symbol :B4
	{
		string data( $1->data, $1->length );
		$$->inlineItem = new InlineItem( @1, data, InlineItem::Text );
	}

	c_inline::block_symbol :B5
	{
		string data( $1->data, $1->length );
		$$->inlineItem = new InlineItem( @1, data, InlineItem::Text );
	}

	c_inline::block_symbol :B6
	{
		string data( $1->data, $1->length );
		$$->inlineItem = new InlineItem( @1, data, InlineItem::Text );
	}

	# def block_interpret
	#	[expr_interpret] :ExprInterpret
	# |	[`fhold whitespace? `;] :Fhold
	# |	[`fgoto whitespace? `* inline_expr `;] :FgotoExpr
	# |	[`fnext whitespace? `* inline_expr `;] :FnextExpr
	# |	[`fcall whitespace? `* inline_expr `;] :FcallExpr
	# |	[`fncall whitespace? `* inline_expr `;] :FncallExpr
	# |	[`fexec inline_expr `;] :Fexec
	# |	[`fgoto state_ref srlex::`;] :FgotoSr
	# |	[`fnext state_ref srlex::`;] :FnextSr
	# |	[`fcall state_ref srlex::`;] :FcallSr
	# |	[`fncall state_ref srlex::`;] :FncallSr
	# |	[`fret `;] :Fret
	# |	[`fnret `;] :Fnret
	# |	[`fbreak `;] :Fbreak
	# |	[`fnbreak `;] :Fnbreak
	c_inline::block_interpret
	{
		InlineItem *inlineItem;
	}

	c_inline::block_interpret :ExprInterpret
	{
		$$->inlineItem = $expr_interpret->inlineItem;
	}


	# def expr_interpret
	#	[`fpc] :Fpc
	# |	[`fc] :Fc
	# |	[`fcurs] :Fcurs
	# |	[`ftargs]  :Ftargs
	# |	[`fentry `( state_ref srlex::`)] :Fentry
	c_inline::expr_interpret
	{
		InlineItem *inlineItem;
	}

	c_inline::expr_interpret :Fpc
	{
		$$->inlineItem = new InlineItem( @1, InlineItem::PChar );
	}

	c_inline::expr_interpret :Fc
	{
		$$->inlineItem = new InlineItem( @1, InlineItem::Char );
	}

	c_inline::expr_interpret :Fcurs
	{
		$$->inlineItem = new InlineItem( @1, InlineItem::Curs );
	}

	c_inline::expr_interpret :Ftargs
	{
		$$->inlineItem = new InlineItem( @1, InlineItem::Targs );
	}

#	c_inline::expr_interpret :Fentry
#	{
#//		NameRef *nameRef = loadStateRef( ExprInterpret.state_ref() );
#//		$$->inlineItem = new InlineItem( @1, nameRef, InlineItem::Entry );
#	}
	
	# def priority_aug
	#	[uint]
	# |	[`+ uint]
	# |	[`- uint]

	# def aug_base
	# 	[`@] :Finish | [`>] :Enter | [`%] :Leave | [`$] :All

	ragel::aug_base
	{
		colm_location loc;
		AugType augType;
	}

	ragel::aug_base :Enter
		{ $$->loc = *@1; $$->augType = at_start; }
	ragel::aug_base :All
		{ $$->loc = *@1; $$->augType = at_all; }
	ragel::aug_base :Finish
		{ $$->loc = *@1; $$->augType = at_finish; }
	ragel::aug_base :Leave
		{ $$->loc = *@1; $$->augType = at_leave; }

	# def aug_cond
	# 	[`>?] :Start1 | [`$?] :All1 | [`%?] :Leave1
	# |	[`> `when] :Start2 | [`$ `when] :All2 | [`% `when] :Leave2
	# |	[`inwhen] :Start3 | [`when] :All3 | [`outwhen] :Leave3

	ragel::aug_cond
	{
		colm_location loc;
		AugType augType;
	}

	ragel::aug_cond :Start1
		{ $$->loc = *@1; $$->augType = at_start; }
	ragel::aug_cond :Start2
		{ $$->loc = *@1; $$->augType = at_start; }
	ragel::aug_cond :Start3
		{ $$->loc = *@1; $$->augType = at_start; }
	ragel::aug_cond :All1
		{ $$->loc = *@1; $$->augType = at_all; }
	ragel::aug_cond :All2
		{ $$->loc = *@1; $$->augType = at_all; }
	ragel::aug_cond :All3
		{ $$->loc = *@1; $$->augType = at_all; }
	ragel::aug_cond :Leave1
		{ $$->loc = *@1; $$->augType = at_leave; }
	ragel::aug_cond :Leave2
		{ $$->loc = *@1; $$->augType = at_leave; }
	ragel::aug_cond :Leave3
		{ $$->loc = *@1; $$->augType = at_leave; }

	# def aug_to_state
	# 	[`>~] :Start1 | [`<~] :NotStart1 | [`$~] :All1
	# |	[`%~] :Final1 | [`@~] :NotFinal1 | [`<>~] :Middle1
	# |	[`> `to] :Start2 | [`< `to] :NotStart2 | [`$ `to] :All2
	# |	[`% `to] :Final2 | [`@ `to] :NotFinal2 | [`<> `to] :Middle2

	ragel::aug_to_state
	{
		AugType augType;	
	}

	ragel::aug_to_state :Start1
		{ $$->augType = at_start_to_state; }
	ragel::aug_to_state :Start2
		{ $$->augType = at_start_to_state; }
	ragel::aug_to_state :NotStart1
		{ $$->augType = at_not_start_to_state; }
	ragel::aug_to_state :NotStart2
		{ $$->augType = at_not_start_to_state; }
	ragel::aug_to_state :All1
		{ $$->augType = at_all_to_state; }
	ragel::aug_to_state :All2
		{ $$->augType = at_all_to_state; }
	ragel::aug_to_state :Final1
		{ $$->augType = at_final_to_state; }
	ragel::aug_to_state :Final2
		{ $$->augType = at_final_to_state; }
	ragel::aug_to_state :NotFinal1
		{ $$->augType = at_not_final_to_state; }
	ragel::aug_to_state :NotFinal2
		{ $$->augType = at_not_final_to_state; }
	ragel::aug_to_state :Middle1
		{ $$->augType = at_middle_to_state; }
	ragel::aug_to_state :Middle2
		{ $$->augType = at_middle_to_state; }

	# def aug_from_state
	# 	[`>*] :Start1 | [`<*] :NotStart1 | [`$*] :All1
	# |	[`%*] :Final1 | [`@*] :NotFinal1 | [`<>*] :Middle1
	# |	[`> `from] :Start2 | [`< `from] :NotStart2 | [`$ `from] :All2
	# |	[`% `from] :Final2 | [`@ `from] :NotFinal2 | [`<> `from] :Middle2

	ragel::aug_from_state
	{
		AugType augType;	
	}

	ragel::aug_from_state :Start1
		{ $$->augType = at_start_from_state; }
	ragel::aug_from_state :Start2
		{ $$->augType = at_start_from_state; }
	ragel::aug_from_state :NotStart1
		{ $$->augType = at_not_start_from_state; }
	ragel::aug_from_state :NotStart2
		{ $$->augType = at_not_start_from_state; }
	ragel::aug_from_state :All1
		{ $$->augType = at_all_from_state; }
	ragel::aug_from_state :All2
		{ $$->augType = at_all_from_state; }
	ragel::aug_from_state :Final1
		{ $$->augType = at_final_from_state; }
	ragel::aug_from_state :Final2
		{ $$->augType = at_final_from_state; }
	ragel::aug_from_state :NotFinal1
		{ $$->augType = at_not_final_from_state; }
	ragel::aug_from_state :NotFinal2
		{ $$->augType = at_not_final_from_state; }
	ragel::aug_from_state :Middle1
		{ $$->augType = at_middle_from_state; }
	ragel::aug_from_state :Middle2
		{ $$->augType = at_middle_from_state; }

	# def aug_eof
	# 	[`>/] :Start1 | [`</] :NotStart1 | [`$/] :All1
	# |	[`%/] :Final1 | [`@/] :NotFinal1 | [`<>/] :Middle1
	# |	[`> `eof] :Start2 | [`< `eof] :NotStart2 | [`$ `eof] :All2
	# |	[`% `eof] :Final2 | [`@ `eof] :NotFinal2 | [`<> `eof] :Middle2

	ragel::aug_eof
	{
		AugType augType;	
	}

	ragel::aug_eof :Start1
		{ $$->augType = at_start_eof; }
	ragel::aug_eof :Start2
		{ $$->augType = at_start_eof; }
	ragel::aug_eof :NotStart1
		{ $$->augType = at_not_start_eof; }
	ragel::aug_eof :NotStart2
		{ $$->augType = at_not_start_eof; }
	ragel::aug_eof :All1
		{ $$->augType = at_all_eof; }
	ragel::aug_eof :All2
		{ $$->augType = at_all_eof; }
	ragel::aug_eof :Final1
		{ $$->augType = at_final_eof; }
	ragel::aug_eof :Final2
		{ $$->augType = at_final_eof; }
	ragel::aug_eof :NotFinal1
		{ $$->augType = at_not_final_eof; }
	ragel::aug_eof :NotFinal2
		{ $$->augType = at_not_final_eof; }
	ragel::aug_eof :Middle1
		{ $$->augType = at_middle_eof; }
	ragel::aug_eof :Middle2
		{ $$->augType = at_middle_eof; }

	# def aug_gbl_error
	# 	[`>!] :Start1 | [`<!] :NotStart1 | [`$!] :All1
	# |	[`%!] :Final1 | [`@!] :NotFinal1 | [`<>!] :Middle1
	# |	[`> `err] :Start2 | [`< `err] :NotStart2 | [`$ `err] :All2
	# |	[`% `err] :Final2 | [`@ `err] :NotFinal2 | [`<> `err] :Middle2

	ragel::aug_gbl_error
	{
		AugType augType;	
	}

	ragel::aug_gbl_error :Start1
		{ $$->augType = at_start_gbl_error; }
	ragel::aug_gbl_error :Start2
		{ $$->augType = at_start_gbl_error; }
	ragel::aug_gbl_error :NotStart1
		{ $$->augType = at_not_start_gbl_error; }
	ragel::aug_gbl_error :NotStart2
		{ $$->augType = at_not_start_gbl_error; }
	ragel::aug_gbl_error :NotStart2
		{ $$->augType = at_not_start_gbl_error; }
	ragel::aug_gbl_error :All1
		{ $$->augType = at_all_gbl_error; }
	ragel::aug_gbl_error :All2
		{ $$->augType = at_all_gbl_error; }
	ragel::aug_gbl_error :Final1
		{ $$->augType = at_final_gbl_error; }
	ragel::aug_gbl_error :Final2
		{ $$->augType = at_final_gbl_error; }
	ragel::aug_gbl_error :NotFinal1
		{ $$->augType = at_not_final_gbl_error; }
	ragel::aug_gbl_error :NotFinal2
		{ $$->augType = at_not_final_gbl_error; }
	ragel::aug_gbl_error :Middle1
		{ $$->augType = at_middle_gbl_error; }
	ragel::aug_gbl_error :Middle2
		{ $$->augType = at_middle_gbl_error; }

	# def aug_local_error
	# 	[`>^] :Start1 | [`<^] :NotStart1 | [`$^] :All1
	# |	[`%^] :Final1 | [`@^] :NotFinal1 | [`<>^] :Middle1
	# |	[`> `lerr] :Start2 | [`< `lerr] :NotStart2 | [`$ `lerr] :All2
	# |	[`% `lerr] :Final2 | [`@ `lerr] :NotFinal2 | [`<> `lerr] :Middle2

	ragel::aug_local_error
	{
		AugType augType;
	}

	ragel::aug_local_error :Start1
		{ $$->augType = at_start_local_error; }

	ragel::aug_local_error :Start2
		{ $$->augType = at_start_local_error; }

	ragel::aug_local_error :NotStart1
		{ $$->augType = at_not_start_local_error; }

	ragel::aug_local_error :NotStart2
		{ $$->augType = at_not_start_local_error; }

	ragel::aug_local_error :All1
		{ $$->augType = at_all_local_error; }

	ragel::aug_local_error :All2
		{ $$->augType = at_all_local_error; }

	ragel::aug_local_error :Final1
		{ $$->augType = at_final_local_error; }

	ragel::aug_local_error :Final2
		{ $$->augType = at_final_local_error; }

	ragel::aug_local_error :NotFinal1
		{ $$->augType = at_not_final_local_error; }

	ragel::aug_local_error :NotFinal2
		{ $$->augType = at_not_final_local_error; }

	ragel::aug_local_error :Middle1
		{ $$->augType = at_middle_local_error; }

	ragel::aug_local_error :Middle2
		{ $$->augType = at_middle_local_error; }

	# def factor_aug
	#	[factor_aug aug_base action_ref] :ActionRef
	# |	[factor_aug aug_base priority_aug] :PriorEmbed
	# |	[factor_aug aug_base `( word `, priority_aug `)] :NamedPriorEmbed
	# |	[factor_aug aug_cond action_ref] :CondEmbed
	# |	[factor_aug aug_cond `! action_ref] :NegCondEmbed
	# |	[factor_aug aug_to_state action_ref] :ToStateAction
	# |	[factor_aug aug_from_state action_ref] :FromStateAction
	# |	[factor_aug aug_eof action_ref] :EofAction
	# |	[factor_aug aug_gbl_error action_ref] :GblErrorAction
	# |	[factor_aug aug_local_error action_ref] :LocalErrorDef
	# |	[factor_aug aug_local_error `( word `, action_ref `)] :LocalErrorName
	# |	[factor_rep] :Base
	ragel::factor_aug
	{
		FactorWithAug *fwa;
	}

	ragel::factor_aug :ActionRef
	{
		/* Append the action to the factorWithAug, record the refernce from 
		 * factorWithAug to the action and pass up the factorWithAug. */
		$_factor_aug->fwa->actions.append( ParserAction(
				&$aug_base->loc, $aug_base->augType, 0, $action_ref->action ) );

		$$->fwa = $_factor_aug->fwa;
	}

	ragel::factor_aug :PriorEmbed
	{
		$$->fwa = $_factor_aug->fwa;
	}

	ragel::factor_aug :NamedPriorEmbed
	{
		$$->fwa = $_factor_aug->fwa;
	}

	ragel::factor_aug :CondEmbed
	{
		$_factor_aug->fwa->conditions.append( ConditionTest( &$aug_cond->loc, 
				$aug_cond->augType, $action_ref->action, true ) );

		$$->fwa = $_factor_aug->fwa;
	}

	ragel::factor_aug :NegCondEmbed
	{
		$_factor_aug->fwa->conditions.append( ConditionTest( &$aug_cond->loc, 
				$aug_cond->augType, $action_ref->action, false ) );

		$$->fwa = $_factor_aug->fwa;
	}

	ragel::factor_aug :ToStateAction
	{
		$$->fwa = $_factor_aug->fwa;
	}
	
	ragel::factor_aug :FromStateAction
	{
		$$->fwa = $_factor_aug->fwa;
	}

	ragel::factor_aug :EofAction
	{
		$$->fwa = $_factor_aug->fwa;
	}

	ragel::factor_aug :GblErrorAction
	{
		$$->fwa = $_factor_aug->fwa;
	}

	ragel::factor_aug :LocalErrorDef
	{
		$$->fwa = $_factor_aug->fwa;
	}

	ragel::factor_aug :LocalErrorName
	{
		$$->fwa = $_factor_aug->fwa;
	}

	ragel::factor_aug :Base
	{
		$$->fwa = new FactorWithAug( $factor_rep->rep );
	}

	#def factor_rep 
	#	[factor_neg factor_rep_op_list] :Op
	#|	[nfa_kw  `( uint `, factor_rep `,
	#		A1: action_ref `, A2: action_ref `, A3: action_ref `, A4: action_ref `,
	#		A5: action_ref `, A6: action_ref `):] :Nfa
	#|	[`:cond  `( uint `, factor_rep `, 
	#		A1: action_ref `, A2: action_ref `, A3: action_ref `, A4: action_ref `):] :Cond
	#|	[`:nomax `( uint `, factor_rep `, 
	#		A1: action_ref `, A2: action_ref `, A3: action_ref `):] :NoMax

	ragel::factor_rep
	{
		FactorWithRep *rep;
	}

	ragel::factor_rep :Op
	{
		FactorWithRep *prev = new FactorWithRep( $factor_neg->neg );
		FactorWithRep *cur = $factor_rep_op_list->rep;
		while ( cur != 0 ) {
			FactorWithRep *next = cur->factorWithRep;

			/* Reverse. */
			cur->factorWithRep = prev;

			prev = cur;
			cur = next;
		}

		$$->rep = prev;
	}

	ragel::factor_rep :Nfa
	{
		string data( $uint->data, $uint->length );
		long long repId = strtoll( data.c_str(), 0, 10);

		/* push, pop, ini, stay, repeat, exit */
		$$->rep = new FactorWithRep( @1, repId, $_factor_rep->rep,
				$A1->action, $A2->action, $A3->action, $A4->action, $A5->action, $A6->action,
				FactorWithRep::NfaRep );
	}

	ragel::factor_rep :Cond
	{
		string data( $uint->data, $uint->length );
		long long repId = strtoll( data.c_str(), 0, 10);

		$$->rep = new FactorWithRep( @1, repId, $_factor_rep->rep,
				$A1->action, $A2->action, $A3->action, $A4->action, 0, 0,
				FactorWithRep::CondRep );
	}

	ragel::factor_rep :NoMax
	{
		string data( $uint->data, $uint->length );
		long long repId = strtoll( data.c_str(), 0, 10);

		$$->rep = new FactorWithRep( @1, repId, $_factor_rep->rep,
				$A1->action, $A2->action, $A3->action, 0, 0, 0,
				FactorWithRep::NoMaxRep );
	}


	# def factor_rep_op_list
	#	[factor_rep_op factor_rep_op_list]
	# |	[]
	ragel::factor_rep_op_list
	{
		FactorWithRep *rep;
	}
	ragel::factor_rep_op_list :Rec
	{
		$$->rep = $factor_rep_op->rep;
		$$->rep->factorWithRep = $_factor_rep_op_list->rep;
	}
	ragel::factor_rep_op_list :Base
	{
		$$->rep = 0;
	}

	# def factor_rep_op
	#	[`*] :Star
	# |	[`**] :StarStar
	# |	[`?] :Optional
	# |	[`+] :Plus
	# |	[`{ factor_rep_num `}] :ExactRep
	# |	[`{ `, factor_rep_num `}] :MaxRep
	# |	[`{ factor_rep_num `, `}] :MinRep
	# |	[`{ LowRep: factor_rep_num `, HighRep: factor_rep_num `}] :RangeRep
	ragel::factor_rep_op
	{
		FactorWithRep *rep;
	}
	ragel::factor_rep_op :Star
	{
		$$->rep = new FactorWithRep( @1, 0, 0, 0, FactorWithRep::StarType );
	}
	ragel::factor_rep_op :StarStar
	{
		$$->rep = new FactorWithRep( @1, 0, 0, 0, FactorWithRep::StarStarType );
	}
	ragel::factor_rep_op :Optional
	{
		$$->rep = new FactorWithRep( @1, 0, 0, 0, FactorWithRep::OptionalType );
	}
	ragel::factor_rep_op :Plus
	{
		$$->rep = new FactorWithRep( @1, 0, 0, 0, FactorWithRep::PlusType );
	}
	ragel::factor_rep_op :ExactRep
	{
		$$->rep = new FactorWithRep( @1, 0,
				$factor_rep_num->rep, 0,
				FactorWithRep::ExactType );
	}
	ragel::factor_rep_op :MaxRep
	{
		$$->rep = new FactorWithRep( @1, 0,
				0, $factor_rep_num->rep,
				FactorWithRep::MaxType );
	}
	ragel::factor_rep_op :MinRep
	{
		$$->rep = new FactorWithRep( @1, 0,
				$factor_rep_num->rep, 0,
				FactorWithRep::MinType );
	}
	ragel::factor_rep_op :RangeRep
	{
		$$->rep = new FactorWithRep( @1, 0,
				$LowRep->rep, $HighRep->rep,
				FactorWithRep::RangeType );
	}

	# def factor_rep_num
	#	[uint]
	ragel::factor_rep_num
	{
		int rep;
	}

	ragel::factor_rep_num :RepNum
	{
		// Convert the priority number to a long. Check for overflow.
		string data( $uint->data, $uint->length );
		errno = 0;
		long rep = strtol( data.c_str(), 0, 10 );
		if ( errno == ERANGE && rep == LONG_MAX ) {
			// Repetition too large. Recover by returing repetition 1. */
			error(@uint) << "repetition number " << data << " overflows" << endl;
			$$->rep = 1;
		}
		else {
			// Cannot be negative, so no overflow.
			$$->rep = rep;
		}
	}


	# def factor_neg 
	#	[`! factor_neg] :Bang
	# |	[`^ factor_neg] :Caret
	# |	[factor] :Base
	ragel::factor_neg
	{
		FactorWithNeg *neg;
	}

	ragel::factor_neg :Bang
	{
		$$->neg = new FactorWithNeg( @1,
				$_factor_neg->neg, FactorWithNeg::NegateType );
	}

	ragel::factor_neg :Caret
	{
		$$->neg = new FactorWithNeg( @1,
				$_factor_neg->neg, FactorWithNeg::CharNegateType );
	}

	ragel::factor_neg :Base
	{
		$$->neg = new FactorWithNeg( $factor->factor );
	}

	# def factor 
	#	[alphabet_num] :AlphabetNum
	# |	[word] :Word
	# |	[string] :String
	# |	[lex_sqopen_pos reg_or_data re_or_sqclose] :PosOrBlock
	# |	[lex_sqopen_neg reg_or_data re_or_sqclose] :NegOrBlock
	# |	[lex_regex_open regex re_close] :Regex
	# |	[RL1: range_lit `.. RL2: range_lit]   :Range
	# |	[RL1: range_lit `../i RL2: range_lit] :RangeIndep
	# |	[`( join `)] :Join
	ragel::factor
	{
		Factor *factor;
	}

	ragel::factor :Join
	{
		/* Create a new factor going to a parenthesized join. */
		$$->factor = new Factor( $join->join );
		$$->factor->join->loc = @1;
	}

	ragel::factor :AlphabetNum
	{
		$$->factor = new Factor( new Literal( $alphabet_num->tok, Literal::Number ) );
	}

	ragel::factor :Word
	{
		InputLoc loc = @word;
		string s( $word->data, $word->length );
		
		/* Find the named graph. */
		GraphDictEl *gdNode = pd->graphDict.find( s );
		if ( gdNode == 0 ) {
			/* Recover by returning null as the factor node. */
			error(loc) << "graph lookup of \"" << s << "\" failed" << endl;
			$$->factor = 0;
		}
		else if ( gdNode->isInstance ) {
			/* Recover by retuning null as the factor node. */
			error(loc) << "references to graph instantiations not allowed "
					"in expressions" << endl;
			$$->factor = 0;
		}
		else {
			/* Create a factor node that is a lookup of an expression. */
			$$->factor = new Factor( loc, gdNode->value );
		}
	}

	ragel::factor :String
	{
		Token tok;
		tok.set( $string );
		$$->factor = new Factor( new Literal( tok, Literal::LitString ) );
	}

	ragel::factor :Range
	{
		$$->factor = new Factor( new Range( $RL1->literal, $RL2->literal, false ) );
	}

	ragel::factor :RangeIndep
	{
		$$->factor = new Factor( new Range( $RL1->literal, $RL2->literal, true ) );
	}

	# |	[lex_sqopen_pos reg_or_data re_or_sqclose] :PosOrBlock
	ragel::factor :PosOrBlock
	{
		$$->factor = new Factor( new ReItem( @lex_sqopen_pos,
				$reg_or_data->reOrBlock, ReItem::OrBlock ) );
	}

	ragel::factor :NegOrBlock
	{
		$$->factor = new Factor( new ReItem( @lex_sqopen_neg,
				$reg_or_data->reOrBlock, ReItem::NegOrBlock ) );
	}

	ragel::factor :Regex
	{
	}

	# def regex
	# 	[reg_item_rep*]

	# def reg_item_rep
	# 	[reg_item re_star] :Star
	# |	[reg_item] :Base

	# def reg_item
	# 	[re_sqopen_pos reg_or_data re_or_sqclose] :PosOrBlock
	# |	[re_sqopen_neg reg_or_data re_or_sqclose] :NegOrBlock
	# |	[re_dot] :Dot
	# |	[re_char] :Char

	# def reg_or_data
	# 	[reg_or_data reg_or_char] :Data
	# |	[] :Base
	ragel::reg_or_data
	{
		ReOrBlock *reOrBlock;
	}

	ragel::reg_or_data :Data
	{
		/* An optimization to lessen the tree size. If an or char is directly
		 * under the left side on the right and the right side is another or
		 * char then paste them together and return the left side. Otherwise
		 * just put the two under a new or data node. */
		if ( $reg_or_char->reOrItem->type == ReOrItem::Data &&
				$_reg_or_data->reOrBlock->type == ReOrBlock::RecurseItem &&
				$_reg_or_data->reOrBlock->item->type == ReOrItem::Data )
		{
			/* Append the right side to right side of the left and toss the
			 * right side. */
			$_reg_or_data->reOrBlock->item->token.append( $reg_or_char->reOrItem->token );
			delete $reg_or_char->reOrItem;
			$$->reOrBlock = $_reg_or_data->reOrBlock;
		}
		else {
			/* Can't optimize, put the left and right under a new node. */
			$$->reOrBlock = new ReOrBlock( $_reg_or_data->reOrBlock, $reg_or_char->reOrItem );
		}
	}

	ragel::reg_or_data :Base
	{
		$$->reOrBlock = new ReOrBlock();
	}

	# def reg_or_char
	# 	[re_or_char] :Char
	# |	[Low: re_or_char re_or_dash High: re_or_char] :Range
	ragel::reg_or_char
	{
		ReOrItem *reOrItem;
	}

	ragel::reg_or_char :Char
	{
		// ReOrItem *reOrItem;
		char *c = unescape( $re_or_char->data, $re_or_char->length );
		Token tok;
		tok.set( c, 1 );
		delete[] c;
		$$->reOrItem = new ReOrItem( @re_or_char, tok );
	}

	ragel::reg_or_char :Range
	{
		// ReOrItem *reOrItem;
		char *low = unescape( $Low->data, $Low->length );
		char *high = unescape( $High->data, $High->length );
		$$->reOrItem = new ReOrItem( @re_or_dash, low[0], high[0] );
	}


	# def alphabet_num 
	#	[uint] :Uint
	# |	[`- uint] :Neg
	# |	[hex] :Hex
	ragel::alphabet_num
	{
		Token tok;
	}

	ragel::alphabet_num :Uint
	{
		$$->tok.set( $uint );
		$$->tok.set( @uint );
	}

	ragel::alphabet_num :Neg
	{
		$$->tok.set( "-", 1 );
		$$->tok.append( $uint->data, $uint->length );
		//$$->tok.loc = @uint;
	}

	# def range_lit
	#	[string] :String
	# |	[alphabet_num] :AN
	ragel::range_lit
	{
		Literal *literal;
	}

	ragel::range_lit :String
	{
		/* Range literals must have only one char. We restrict this in the
		 * parse tree. */
		Token tok;
		tok.set( $string );
		$$->literal = new Literal( tok, Literal::LitString );
	}

	ragel::range_lit :AN
	{
		$$->literal = new Literal( $alphabet_num->tok, Literal::Number );
	}


	ragel::alphabet_num :Hex
	{
		$$->tok.set( $hex );
		$$->tok.set( @hex );
	}

	# def assignment
	#	[opt_export word `= join `;] :Assignment commit
	ragel::assignment :Assignment
	{
		InputLoc loc = @word;

		bool exportMachine = $opt_export->isSet;
		if ( exportMachine )
			exportContext.append( true );

		string name( $word->data, $word->length );
		loadMachineName( name );

		/* Main machine must be an instance. */
		bool isInstance = false;
		if ( name == MAIN_MACHINE ) {
			warning(loc) << "main machine will be implicitly instantiated" << endl;
			isInstance = true;
		}

		MachineDef *machineDef = new MachineDef( $join->join );

		/* Generic creation of machine for instantiation and assignment. */
		tryMachineDef( loc, name, machineDef, isInstance );

		if ( exportMachine )
			exportContext.remove( exportContext.length()-1 );

		/* Pass a location to join_or_lm */
		if ( machineDef->join != 0 )
			machineDef->join->loc = loc;
	}

	
	# def lm
	#	[join] :Join
	# |	[`|* lm_stmt_list `*|] :Lm
	ragel::lm
	{
		Join *join;
	}

	ragel::lm :Join
	{
		$$->join = $join->join;
	}

	ragel::lm :Lm
	{
		$$->join = 0;
	}


	# def instantiation
	#	[opt_export word `:= lm `;] :Instantiation commit
	ragel::instantiation :Instantiation
	{
		InputLoc loc = @word;

		bool exportMachine = $opt_export->isSet;
		if ( exportMachine )
			exportContext.append( true );

		string name( $word->data, $word->length );
		loadMachineName( name );

		MachineDef *machineDef = new MachineDef( $lm->join );

		/* Generic creation of machine for instantiation and assignment. */
		tryMachineDef( loc, name, machineDef, true );

		if ( exportMachine )
			exportContext.remove( exportContext.length()-1 );

		/* Pass a location to join_or_lm */
		if ( machineDef->join != 0 )
			machineDef->join->loc = loc;
	}

	# def opt_export
	#	[`export] :Export
	# |	[] :Base
	ragel::opt_export
	{
		bool isSet;
	}

	ragel::opt_export :Export
	{
		$$->isSet = true;
	}

	ragel::opt_export :Base
	{
		$$->isSet = false;
	}


	# def nfa_expr
	#	[nfa_expr `| term] :Union
	# |	[term] :Base
	ragel::nfa_expr
	{
		NfaUnion *nfaUnion;
	}

	ragel::nfa_expr :Union
	{
		$$->nfaUnion = $_nfa_expr->nfaUnion;
		$$->nfaUnion->terms.append( $term->term );
	}

	ragel::nfa_expr :Base
	{
		$$->nfaUnion = new NfaUnion();
		$$->nfaUnion->terms.append( $term->term );
	}
	
	# def nfa_round_spec
	#	[uint `, uint]
	ragel::nfa_round_spec
	{
		long depth;
		long group;
	}

	ragel::nfa_round_spec :Spec
	{
		// Convert the priority number to a long. Check for overflow.
		errno = 0;
		$$->depth = strtol( $Depth->data, 0, 10 );
		if ( $$->depth == LONG_MAX && errno == ERANGE )
			error(@Depth) << "rounds " << $Depth->data << " overflows" << endl;

		$$->group = strtol( $Group->data, 0, 10 );
		if ( $$->group == LONG_MAX && errno == ERANGE )
			error(@Groups) << "group " << $Group->data << " overflows" << endl;
	}

	# def nfa_round_list
	#	[nfa_round_list `, nfa_round_spec] :Recurse
	# |	[nfa_round_spec] :Base
	ragel::nfa_round_list
	{
		NfaRoundVect *roundsList;
	}

	ragel::nfa_round_list :Recurse
	{
		$$->roundsList = $_nfa_round_list->roundsList;
		$$->roundsList->append( NfaRound( $nfa_round_spec->depth,
				$nfa_round_spec->group ) );
	}

	ragel::nfa_round_list :Base
	{
		$$->roundsList = new NfaRoundVect;
		$$->roundsList->append( NfaRound( $nfa_round_spec->depth,
				$nfa_round_spec->group ) );
	}

	# def nfa_rounds
	#	[`( nfa_round_list `)] :Rounds
	ragel::nfa_rounds
	{
		NfaRoundVect *roundsList;
	}

	ragel::nfa_rounds :Rounds
	{
		$$->roundsList = $nfa_round_list->roundsList;
	}

	# def nfa_union
	#	[word `|= nfa_rounds nfa_expr `;] :NfaUnion commit
	ragel::nfa_union :NfaUnion
	{
		InputLoc loc = @word;
		string name( $word->data, $word->length );

		$nfa_expr->nfaUnion->roundsList = $nfa_rounds->roundsList;

		MachineDef *machineDef = new MachineDef( $nfa_expr->nfaUnion );

		/* Generic creation of machine for instantiation and assignment. */
		tryMachineDef( loc, name, machineDef, true );
	}

	# def alphtype_type
	#	[W1: word] :One
	# |	[W1: word W2: word] :Two
	ragel::alphtype_type :One
	{
		string one( $W1->data, $W1->length );
		if ( ! pd->setAlphType( @W1, hostLang, one.c_str() ) ) {
			// Recover by ignoring the alphtype statement.
			error(@W1) << "\"" << one << 
					"\" is not a valid alphabet type" << endl;
		}
	}

	ragel::alphtype_type :Two
	{
		string one( $W1->data, $W1->length );
		string two( $W2->data, $W2->length );
		if ( ! pd->setAlphType( @W1, hostLang, one.c_str(), two.c_str() ) ) {
			// Recover by ignoring the alphtype statement.
			error(@W1) << "\"" << one << 
					"\" is not a valid alphabet type" << endl;
		}
	}

	# [`nfaprepush action_block] :NfaPrePush commit
	ragel::statement :NfaPrePush
	{
		if ( pd->nfaPrePushExpr != 0 ) {
			/* Recover by just ignoring the duplicate. */
			error(@1) << "nfa_pre_push code already defined" << endl;
		}

		pd->nfaPrePushExpr = new InlineBlock( @1, $action_block->inlineList );
	}

	# [`nfapostpop action_block] :NfaPostPop commit
	ragel::statement :NfaPostPop
	{
		if ( pd->nfaPostPopExpr != 0 ) {
			/* Recover by just ignoring the duplicate. */
			error(@1) << "nfa_post_pop code already defined" << endl;
		}

		pd->nfaPostPopExpr = new InlineBlock( @1, $action_block->inlineList );
	}

	# def include_spec
	#	[word] :Machine
	# |	[string] :File
	# |	[word string] :MachineFile

	ragel::include_spec 
	{
		Token machine;
		Token file;
	}

	ragel::include_spec :Machine
	{
		$$->machine.set( $word );
		$$->machine.set( @word );
		$$->file.data = 0;
	}

	ragel::include_spec :File
	{
		$$->file.set( $string );
		$$->file.set( @string );
		$$->machine.data = 0;
	}

	ragel::include_spec :MachineFile
	{
		$$->machine.set( $word );
		$$->machine.set( @word );
		$$->file.set( $string );
		$$->file.set( @string );
	}
	
	# [`include include_spec `;] :Include commit
	ragel::statement :Include
	{
		string fileName = id->inputFileName;
		string machine = pd->sectionName;

		if ( $include_spec->file.data != 0 ) {
			fileName = string( $include_spec->file.data, $include_spec->file.length );

			InputLoc loc = $include_spec->file.loc;
			long length;
			bool caseInsensitive;
			char *unescaped = prepareLitString( loc, fileName.c_str(), fileName.size(),
					length, caseInsensitive );
			fileName = unescaped;
		}

		if ( $include_spec->machine.data != 0 )
			machine = string( $include_spec->machine.data, $include_spec->machine.length );

		/* Stash the current section name and pd. */
		string sectionName = pd->sectionName;
		ParseData *pd0 = pd;

		IncludeRec *el = id->includeDict.find( FnMachine( fileName, machine ) );
		if ( el == 0 ) {
			el = new IncludeRec( fileName, machine );

			InputData idr, *id0 = id;
			
			pd = 0;
			current = 1;
			id = &idr;

			this->reduceFile( fileName.c_str() );

			/* Count bytes. */
			int len = 0;
			for ( InputItem *ii = id->inputItems.head; ii != 0; ii = ii->next ) {
				if ( ii->section != 0 && ii->section->sectionName == machine )
					len += ii->end - ii->start + 3;
			}

			/* Load bytes. */
			el->data = new char[len+1];
			len = 0;
			for ( InputItem *ii = id->inputItems.head; ii != 0; ii = ii->next ) {
				if ( ii->section != 0 && ii->section->sectionName == machine ) {
					std::ifstream f( fileName.c_str() );
					f.seekg( ii->start, std::ios::beg );
					f.read( el->data + len, ii->end - ii->start + 3 );
					len += f.gcount();
				}
			}
			el->data[len] = 0;
			el->len = len;

			id = id0;
			current = 0;

			id->includeDict.insert( el );
		}

		const char *targetMachine0 = targetMachine;
		const char *searchMachine0 = searchMachine;

		includeDepth += 1;
		pd = 0;

		targetMachine = sectionName.c_str();
		searchMachine = machine.c_str();

		this->reduceString( el->data );
		std::cout << el->data;

		pd = pd0;
		includeDepth -= 1;

		targetMachine = targetMachine0;
		searchMachine = searchMachine0;
	}

	ragel::statement :Write
	{
		if ( includeDepth == 0 ) {
			id->curItem = id->curItem->next;
			InputItem *inputItem = id->curItem;

			string cmd( $Cmd->data, $Cmd->length );
			inputItem->writeArgs.append( cmd );
			inputItem->writeArgs.append( writeArgs );

			inputItem->pd = pd;
		}

		/* Clear the write args collector. */
		writeArgs.empty();
	}

	ragel::machine_name :MachineName
	{
		InputLoc sectionLoc;
		string fileName = "input.rl";
		string machine( $word->data, $word->length );

		if ( includeDepth > 0 ) {
			/* Check if the the machine is the one we are searching for. If
			 * not, reset pd. Otherwise, rename it to target machine because we
			 * are drawing the statements into target. */
			if ( machine == searchMachine )
				machine = targetMachine;
		}

		SectionDictEl *sdEl = id->sectionDict.find( machine.c_str() );
		if ( sdEl == 0 ) {
			Section *section = new Section( strdup(machine.c_str() ) );
			sdEl = new SectionDictEl( section->sectionName );
			sdEl->value = section;
			id->sectionDict.insert( sdEl );
		}

		ParseDataDictEl *pdEl = id->parseDataDict.find( machine );
		if ( pdEl == 0 ) {
			pdEl = new ParseDataDictEl( machine );
			pdEl->value = new ParseData( id, fileName, machine,
					id->nextMachineId++, sectionLoc, hostLang,
					minimizeLevel, minimizeOpt );
			id->parseDataDict.insert( pdEl );
			id->parseDataList.append( pdEl->value );
		}

		section = sdEl->value;
		pd = pdEl->value;
	}

	ragel::write_arg :Word
	{
		string arg( $word->data, $word->length );
		writeArgs.append( arg );
	}

	# Pass Through.
	# def tok
	# 	[ident] :Ident
	# |	[number] :Number
	# |	[hex_number] :HexNumber
	# |	[comment] :Comment
	# |	[string] :String
	# |	[whitespace] :Whitespace
	# |	[c_any] :Any
	c_host::tok :Ident
	{
		if ( includeDepth == 0 )
			id->curItem->data.write( $ident->data, $ident->length );
	}

	c_host::tok :Number
	{
		if ( includeDepth == 0 )
			id->curItem->data.write( $number->data, $number->length );
	}

	c_host::tok :HexNumber
	{
		if ( includeDepth == 0 )
			id->curItem->data.write( $hex_number->data, $hex_number->length );
	}

	c_host::tok :Comment
	{
		if ( includeDepth == 0 )
			id->curItem->data.write( $comment->data, $comment->length );
	}

	c_host::tok :String
	{
		if ( includeDepth == 0 )
			id->curItem->data.write( $string->data, $string->length );
	}

	c_host::tok :Whitespace
	{
		if ( includeDepth == 0 )
			id->curItem->data.write( $whitespace->data, $whitespace->length );
	}

	c_host::tok :Any
	{
		if ( includeDepth == 0 )
			id->curItem->data.write( $c_any->data, $c_any->length );
	}

	c_host::section :MultiLine
	{
		if ( includeDepth == 0 ) {
			id->curItem = id->curItem->next;
			id->curItem->pd = pd;
			id->checkLastRef( id->curItem );
			id->curItem = id->curItem->next;
		}
	}
end 

reduction SectionPass
	ragel::machine_name :MachineName
	{
		string machine( $word->data, $word->length );

		SectionDictEl *sdEl = id->sectionDict.find( machine );
		if ( sdEl == 0 ) {
			sdEl = new SectionDictEl( machine );
			sdEl->value = new Section( machine );
			id->sectionDict.insert( sdEl );
		}

		section = sdEl->value;
	}

	ragel::statement :Write
	{
		InputItem *inputItem = new InputItem;
		inputItem->type = InputItem::Write;
		inputItem->loc = @Cmd;
		inputItem->name = section->sectionName;
		inputItem->section = section;

		id->inputItems.append( inputItem );
	}

	c_host::section :MultiLine
	{
		InputItem *inputItem = new InputItem;
		inputItem->type = InputItem::EndSection;
		inputItem->loc = @3;
		inputItem->start = @1->byte;
		inputItem->end = @3->byte + 3;
		id->inputItems.append( inputItem );

		if ( section != 0 ) {
			inputItem->section = section;
			section->lastReference = inputItem;
		}

		if ( includeDepth == 0 ) {
			/* The end section may include a newline on the end, so
			 * we use the last line, which will count the newline. */
			InputItem *inputItem = new InputItem;
			inputItem->type = InputItem::HostData;
			inputItem->loc = @3;
			if ( inputItem->loc.fileName == 0 )
				inputItem->loc = @1;
				
			id->inputItems.append( inputItem );
		}
	}
end
