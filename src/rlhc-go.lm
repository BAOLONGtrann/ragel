
namespace go_out
	token _IN_ /''/
	token _EX_ /''/

	lex
		token comment /
			'//' any* :> '\n' |
			'/*' any* :>> '*/'
		/

		token id
			/[a-zA-Z_][a-zA-Z_0-9]*/

		token number /
			[0-9]+
		/

		token symbol /
			'!' | '#' | '$' | '%' | '&' | '(' | ')' | '*' |
			'+' | ',' | '-' | '.' | '/' | ':' | ';' | '<' |
			'=' | '>' | '?' | '@' | '[' | ']' | '^' | '|' |
			'~' /

		literal `{ `}

		token string /
				'"' ( [^"\\] | '\\' any ) * '"' |
				"'" ( [^'\\] | '\\' any ) * "'"
			/

		ignore
			/[ \t\v\r\n]+/
	end

	def item
		[comment]
	|	[id]
	|	[number]
	|	[symbol]
	|	[string]
	|	[`{ _IN_ item* _EX_ `} ]

	def go_out
		[_IN_ _EX_ item*]
end

global GoParser: parser<go_out::go_out>

void go_tok_list( TL: host::tok* )
{
	for Tok: host::tok in repeat(TL) {
		if match Tok [host::`${ StmtList: stmt* host::`}$]
			send GoParser "{[go_stmt_list( StmtList )]}"
		elsif match Tok [host::`={ Expr: expr host::`}=]
			send GoParser "([go_expr( Expr )])"
		else
			send GoParser [Tok]
	}
}

void go_embedded_host( EmbeddedHost: embedded_host )
{
	switch EmbeddedHost
	case [`host `( string `, uint `) `={ TL: host::tok* host::`}=]
	{
		send GoParser
			"([go_tok_list( TL )])"
	}
	case [`host `( string `, uint `) `${ TL: host::tok* host::`}$]
	{
		send GoParser 
			"{[go_tok_list( TL )]}
	}
	case [`host `( string `, uint `) `@{ TL: host::tok* host::`}@]
	{
		send GoParser
			[go_tok_list( TL )]
	}
}

void go_expr_factor( ExprFactor: expr_factor )
{
	if match ExprFactor
		[EH: embedded_host]
	{
		send GoParser
			[go_embedded_host(EH)]
	}
	elsif match ExprFactor
		[O:`( TL: expr C: `)]
	{
		send GoParser [O]
		go_expr( TL )
		send GoParser [C]
	}
	elsif match ExprFactor
		[ident O: `[ TL: expr C: `]]
	{
		send GoParser [ExprFactor.ident O]
		go_expr( TL )
		send GoParser [C]
	}
	elsif match ExprFactor
		[`offset `( ident `, expr `)]
	{
		send GoParser ['int(']
		go_expr( ExprFactor.expr )
		send GoParser [')']
	}
	elsif match ExprFactor
		['deref' '(' ident ',' expr ')']
	{
		send GoParser [ ExprFactor.ident '[']
		go_expr( ExprFactor.expr )
		send GoParser [']']
	}
	elsif match ExprFactor
			[T: `TRUE]
	{
		T.data = 'true'
		send GoParser [T]
	}
	elsif match ExprFactor
			[F: `FALSE]
	{
		F.data = '0'
		send GoParser [F]
	}
	elsif match ExprFactor
			[N: `nil]
	{
		N.data = '0'
		send GoParser [N]
	}
	elsif match ExprFactor [E1: embedded_host `-> E2: expr_factor]
	{
		go_embedded_host( E1 )
		go_expr_factor( E2 )
	}
	elsif match ExprFactor ['(' Type: type ')' expr_factor]
	{
		go_type( Type )
		send GoParser ['(']
		go_expr_factor( ExprFactor._expr_factor )
		send GoParser [')']
	}
	else {
		# Catches cases not specified
		send GoParser [ExprFactor]
	}
}

void go_lvalue( ExprFactor: lvalue )
{
	if match ExprFactor
		[EH: embedded_host]
	{
		send GoParser
			[go_embedded_host(EH)]
	}
	elsif match ExprFactor
		[ident O: `[ TL: expr C: `]]
	{
		send GoParser [ExprFactor.ident O]
		go_expr( TL )
		send GoParser [C]
	}
	elsif match ExprFactor [E1: embedded_host `-> E2: lvalue]
	{
		go_embedded_host( E1 )
		go_lvalue( E2 )
	}
	else {
		# Catches cases not specified
		send GoParser [ExprFactor]
	}
}

void go_expr_factor_op( ExprFactorOp: expr_factor_op )
{
	if match ExprFactorOp [B: `! expr_factor_op]
	{
		send GoParser [B]
		go_expr_factor_op( ExprFactorOp._expr_factor_op )
	}
	elsif match ExprFactorOp [T: `~ expr_factor_op]
	{
		send GoParser ['^']
		go_expr_factor_op( ExprFactorOp._expr_factor_op )
	}
	elsif match ExprFactorOp [expr_factor]
	{
		go_expr_factor( ExprFactorOp.expr_factor )
	}
}

void go_expr_bitwise( ExprBitwise: expr_bitwise )
{
	if match ExprBitwise [expr_bitwise A: `& expr_factor_op]
	{
		go_expr_bitwise( ExprBitwise._expr_bitwise )
		send GoParser [A]
		go_expr_factor_op( ExprBitwise.expr_factor_op )
	}
	elsif match ExprBitwise [expr_factor_op]
	{
		go_expr_factor_op( ExprBitwise.expr_factor_op )
	}
}

void go_expr_mult( ExprMult: expr_mult )
{
	if match ExprMult [expr_mult T: `* expr_bitwise]
	{
		go_expr_mult( ExprMult._expr_mult )
		send GoParser [T]
		go_expr_bitwise( ExprMult.expr_bitwise )
	}
	elsif match ExprMult [expr_bitwise]
	{
		go_expr_bitwise( ExprMult.expr_bitwise )
	}
}

void go_expr_add( ExprAdd: expr_add )
{
	if match ExprAdd [expr_add Op: add_op expr_mult]
	{
		go_expr_add( ExprAdd._expr_add )
		send GoParser [Op]
		go_expr_mult( ExprAdd.expr_mult )
	}
	elsif match ExprAdd [expr_mult]
	{
		go_expr_mult( ExprAdd.expr_mult )
	}
}

void go_expr_shift( ExprShift: expr_shift )
{
	if match ExprShift [expr_shift Op: shift_op expr_add]
	{
		go_expr_shift( ExprShift._expr_shift )
		send GoParser [Op]
		go_expr_add( ExprShift.expr_add )
	}
	elsif match ExprShift [expr_add]
	{
		go_expr_add( ExprShift.expr_add )
	}
}

void go_expr_test( ExprTest: expr_test )
{
	if match ExprTest [expr_test Op: test_op expr_shift]
	{
		go_expr_test( ExprTest._expr_test )
		send GoParser [Op]
		go_expr_shift( ExprTest.expr_shift )
	}
	elsif match ExprTest [expr_shift]
	{
		go_expr_shift( ExprTest.expr_shift )
	}
}

void go_expr( Expr: expr )
{
	go_expr_test( Expr.expr_test )
}

void go_type( Type: type )
{
	if match Type "s8"
		send GoParser ['int8 ']
	elsif match Type "s16"
		send GoParser ['int16 ']
	elsif match Type "s32"
		send GoParser ['int32 ']
	elsif match Type "s64"
		send GoParser ['int64 ']
	elsif match Type "s128"
		send GoParser ['long long ']
	else
		send GoParser [Type]
}

void go_number( Number: number )
{
	if match Number [`u `( uint `) ]
		send GoParser [Number.uint]
	else
		send GoParser [Number]
}

void go_num_list( NumList: num_list )
{
	go_number( NumList.number )
	for CommaNum: comma_num in NumList {
		send GoParser [', ']
		go_number( CommaNum.number )
	}
}

void go_stmt( Stmt: stmt )
{
	if match Stmt
		[EH: embedded_host]
	{
		send GoParser
			[go_embedded_host(EH)]
	}
	elsif match Stmt [Array: array] {
		send GoParser
			"var [Array.ident] \[\] [go_type(Array.type)] = \[\] "
				"[go_type(Array.type)] { [go_num_list(Array.num_list)] }
	}
	elsif match Stmt [Value: value] {
		send GoParser
			"var [Value.ident] [go_type(Value.type)] = [Value.number]
	}
	elsif match Stmt [
			'if' O: `( IfExpr: expr C: `) IfStmt: stmt
	] {
		# if-statements with only the if clause can go out as an if.
		send GoParser
			"if [go_expr(IfExpr)] {
			"	[go_stmt(IfStmt)]
			"}
	}
	elsif match Stmt [
			'if' O: `( IfExpr: expr C: `) IfStmt: stmt
			ElseIfClauseList: else_if_clause* ElseClauseOpt: else_clause?
	] {
		# If the if-statement has more than just an if clause it goes out as a switch.
		send GoParser 
			"switch {
			"	case [go_expr( IfExpr )]:
			"		[go_stmt( IfStmt )]

		for ElseIfClause: else_if_clause in repeat( ElseIfClauseList ) {
			match ElseIfClause
				['else if (' ElseIfExpr: expr ')' ElseIfStmt: stmt]

			send GoParser
				"case [go_expr(ElseIfExpr)]:
				"	[go_stmt(ElseIfStmt)]
		}

		if ( match ElseClauseOpt ['else' ElseStmt: stmt] ) {
			send GoParser
				"default:
				"	[go_stmt(ElseStmt)]
		}
		send GoParser
			"}
	}
	elsif match Stmt ["while ( TRUE )" WhileStmt: stmt] {
		send GoParser
			"for {
			"	[go_stmt(WhileStmt)]
			"}
	}
	elsif match Stmt ['while' '(' WhileExpr: expr ')' WhileStmt: stmt] {
		send GoParser
			"for [go_expr(WhileExpr)] {
			"	[go_stmt(WhileStmt)]
			"}
	}
	elsif match Stmt ['switch' '(' SwitchExpr: expr ')' '{' StmtList: stmt* '}'] {
		send GoParser
			"switch [go_expr(SwitchExpr)] {
			"	[go_stmt_list(StmtList)]
			"}
	}
	elsif match Stmt [ExprExpr: expr Semi: `;] {
		send GoParser
			[go_expr(ExprExpr) Semi]
	}
	elsif match Stmt [L: `{ TL: stmt* R: `}] {
		send GoParser
			[L go_stmt_list(TL) R]
	}
	elsif match Stmt [D: declaration]
	{
		send GoParser
			"var  [D.ident] [go_type(D.type)]"

		if match D.opt_init ['=' Expr: expr] {
			send GoParser
				"  = [go_expr(Expr)]"
		}
		send GoParser ['\n']
	}
	elsif match Stmt [export_stmt]
	{
		send GoParser
			"#define  [Stmt.export_stmt.ident] [go_number(Stmt.export_stmt.number)]
	}
	elsif match Stmt ['fallthrough' ';']
	{
		send GoParser
			"fallthrough
	}
	elsif match Stmt [index_stmt]
	{
		send GoParser
			"var  [Stmt.index_stmt.ident] int
	}
	elsif match Stmt [case_block]
	{
		send GoParser
			"case [go_expr( Stmt.case_block.expr )]:
			"[go_stmt_list( Stmt.case_block._repeat_stmt )]
			"break;
	}
	elsif match Stmt [default_block]
	{
		send GoParser
			"default:
			"[go_stmt_list( Stmt.default_block._repeat_stmt )]
			"break;
	}
	elsif match Stmt [case_label]
	{
		send GoParser
			"case [go_expr( Stmt.case_label.expr )]:
	}
	elsif match Stmt [label_stmt]
	{
		send GoParser
			"[Stmt.label_stmt.ident]:
			"[go_stmt_list( Stmt.label_stmt._repeat_stmt )]
	}
	elsif match Stmt [entry_loop]
	{
		send GoParser
			[go_stmt_list( Stmt.entry_loop._repeat_stmt )]
	}
	elsif match Stmt [AS: assign_stmt]
	{
		send GoParser
			"[go_lvalue(AS.LValue) AS.assign_op go_expr(AS.expr)];
	}
	else {
		# catches unspecified cases
		send GoParser [Stmt]
	}
}

void go_stmt_list( StmtList: stmt* )
{
	for Stmt: stmt in repeat( StmtList )
		go_stmt( Stmt )
}

void go_trans( StmtList: stmt* )
{
	GoParser = new parser<go_out::go_out>()

	go_stmt_list( StmtList )

	GO: go_out::go_out = GoParser->finish()

	if GO {
		send Output
			[GO]
	}
	else {
		send stderr
			"failed to parse output: [Parser->error]
	}
}
